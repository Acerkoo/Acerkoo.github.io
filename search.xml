<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[洛谷省选——单调队列]]></title>
    <url>%2F2019%2F05%2F05%2FMonotonicQueue%2F</url>
    <content type="text"><![CDATA[T1题意花盆 给出n个点的坐标，以及时间差d。求区间内y坐标的最大值与最小值差大于等于d 的最小x轴区间长度。 (n&lt;=1e5, d&lt;=1e6, x,y&lt;=1e6) 思路 设l为一段满足条件的区间的左端点，r为该区间最小右端点，则r具有单调性。 『 单调性证明： 设端点l1满足条件的最小右端点为r1, 端点l2（l2&gt;=l1)满足条件的最小右端点为r2。 则： r2&gt;=r1, 否则端点l1满足条件的最小右端点为r2，矛盾。 故: r具有单调性。 』 因此可在对n个点按x排序之后，枚举左端点，用单调队列维护满足条件的区间的y轴上的最大值与最小值。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define I __inline__ __attribute((always_inline))#define ri register intusing namespace std;const int inf = 0x3f3f3f3f;const int maxn = 1e5 + 10;I char readc()&#123; static char buf[100000],*p1=buf,*p2=buf; return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;&#125;I int readI( )&#123; static char c=readc();ri x,f=1; for(;c&gt;'9'||c&lt;'0';c=readc()) if(c=='-') f=-1; for(x=0;c&lt;='9'&amp;&amp;c&gt;='0';c=readc()) x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; return x*f;&#125;struct node &#123; int x, y; void read() &#123; x = readI(), y = readI(); &#125; inline bool operator&lt;(const node &amp;p) const &#123; return x &lt; p.x; &#125;&#125; rain[maxn];int q1[maxn], h1=1, t1;int q2[maxn], h2=1, t2;int n, d;int ans = inf;int main() &#123; n = readI(), d = readI(); for (int i = 1; i &lt;= n; ++i) rain[i].read(); sort(rain + 1, rain + 1 + n); for (register int l = 1, r = 0; l &lt;= n; ++l) &#123; while (h1 &lt;= t2 &amp;&amp; q1[h1] &lt; l) ++h1; while (h2 &lt;= t2 &amp;&amp; q2[h2] &lt; l) ++h2; while (rain[q1[h1]].y - rain[q2[h2]].y &lt; d &amp;&amp; r &lt; n) &#123; ++r; while (h1 &lt;= t1 &amp;&amp; rain[q1[t1]].y &lt; rain[r].y) --t1; q1[++t1] = r; while (h2 &lt;= t2 &amp;&amp; rain[q2[t2]].y &gt; rain[r].y) --t2; q2[++t2] = r; &#125; if (rain[q1[h1]].y - rain[q2[h2]].y &gt;= d) ans = min(ans, rain[r].x - rain[l].x); &#125; if(ans == inf) ans = -1; printf("%d\n", ans); return 0;&#125; T2题意 理想的正方形 有一个a*b的整数组成的矩阵，现请你从中找出一个n*n的正方形区域，使得该区域所有数中的最大值和最小值的差最小。(a, b&lt;=1000, n&lt;=100) 思路 首先对于每一行可以用单调队列维护每n个元素的最大值与最小值，并分别存到两个数组中。 然后对于每一列依旧用单调队列分别维护最大值数组每n个元素的最大值与最小值数组中每n个元素的最小值，得到新的最大值与最小值数组。 答案即为新的最大值数组与最小值数组差的最小值。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define ri register intusing namespace std;const int inf = 0x3f3f3f3f;const int maxn = 1e3 + 10;int q1[maxn], q2[maxn];int mp[maxn][maxn], a, b, n;int mx[maxn][maxn], mi[maxn][maxn];int mxy[maxn][maxn], miy[maxn][maxn];int ans = inf;int main() &#123;// freopen("P2216.in","r", stdin); ri h1 = 1, h2 = 1, t1 = 0, t2 = 0; scanf("%d%d%d", &amp;a, &amp;b, &amp;n); for (ri i = 1; i &lt;= a; ++i) &#123; for (ri j = 1; j &lt;= b; ++j) scanf("%d", &amp;mp[i][j]); &#125; for (ri i = 1; i &lt;= a; ++i) &#123; h1 = h2 = 1; t1 = t2 = 0; for (ri j = 1; j &lt;= b; ++j) &#123; while (h1 &lt;= t1 &amp;&amp; q1[h1] &lt;= j - n) ++h1; while (h2 &lt;= t2 &amp;&amp; q2[h2] &lt;= j - n) ++h2; while (h1 &lt;= t1 &amp;&amp; mp[i][q1[t1]] &lt; mp[i][j]) --t1; q1[++t1] = j; while (h2 &lt;= t2 &amp;&amp; mp[i][q2[t2]] &gt; mp[i][j]) --t2; q2[++t2] = j; if (j &gt;= n) mx[i][j] = mp[i][q1[h1]], mi[i][j] = mp[i][q2[h2]]; &#125; &#125; for (ri j = 1; j &lt;= b; ++j) &#123; h1 = h2 = 1; t1 = t2 = 0; for (ri i = 1; i &lt;= a; ++i) &#123; while (h1 &lt;= t1 &amp;&amp; q1[h1] &lt;= i - n) ++h1; while (h2 &lt;= t2 &amp;&amp; q2[h2] &lt;= i - n) ++h2; while (h1 &lt;= t1 &amp;&amp; mx[q1[t1]][j] &lt; mx[i][j]) --t1; q1[++t1] = i; while (h2 &lt;= t2 &amp;&amp; mi[q2[t2]][j] &gt; mi[i][j]) --t2; q2[++t2] = i; if (i &gt;= n) mxy[i][j] = mx[q1[h1]][j], miy[i][j] = mi[q2[h2]][j]; &#125; &#125; for (int i = n; i &lt;= a; ++i) &#123; for (int j = n; j &lt;= b; ++j) ans = min(ans, mxy[i][j] - miy[i][j]); &#125; printf("%d\n", ans); return 0;&#125; T3题意 修筑绿化带 在一个n*m的矩形里，框出一个a*b的矩形A，在这个矩形内部（不相交）框出一个c*d的矩形B，使得矩形A的权值和-矩形B的权值和最大，求最大权值和。 1&lt;=M,N&lt;=1000,1&lt;=A&lt;=M,1&lt;=B&lt;=N,1&lt;=C&lt;=A-2,1&lt;=D&lt;=B-2，1&lt;=“肥沃度”&lt;=100 思路 使差最大就 要是被减数尽可能大，减数尽可能小，所以就要用单调队列维护矩形为a*b的最大值，以及单调队列维护矩形为c*d的最小值。 维护时要注意边界条件 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3+10;int n, m, a, b, c, d;int mp[maxn][maxn];int tmp[maxn][maxn], res[maxn][maxn];int pref[maxn][maxn], preg[maxn][maxn];int ans = -1;int que[maxn*maxn], h, t;int main() &#123;// freopen("text.in", "r", stdin); scanf("%d%d%d%d%d%d", &amp;n, &amp;m, &amp;a, &amp;b, &amp;c, &amp;d); for (int i=1; i&lt;=n; ++i) &#123; for (int j=1; j&lt;=m; ++j) &#123; scanf("%d", &amp;mp[i][j]); mp[i][j] += mp[i-1][j] + mp[i][j-1] - mp[i-1][j-1]; &#125; &#125; for (int i=c+1; i&lt;n; ++i) &#123; for (int j=d+1; j&lt;m; ++j) pref[i][j] = mp[i][j] - mp[i-c][j] - mp[i][j-d] + mp[i-c][j-d]; &#125; for (int i=a; i&lt;=n; ++i) &#123; for (int j=b; j&lt;=m; ++j) preg[i][j] = mp[i][j] - mp[i-a][j] - mp[i][j-b] + mp[i-a][j-b]; &#125; for (int i=c+1; i&lt;n; ++i) &#123; h = 1, t = 0; for (int j=d+1; j&lt;m; ++j) &#123; while(h&lt;=t &amp;&amp; que[h]&lt;=j-(b-d-2)) ++h; while(h&lt;=t &amp;&amp; pref[i][que[t]]&gt;pref[i][j]) --t; que[++t] = j; if(j&gt;=b-1) tmp[i][j+1] = pref[i][que[h]]; &#125; &#125; for (int j=b; j&lt;=m; ++j) &#123; h = 1, t = 0; for (int i=c+1; i&lt;n; ++i) &#123; while(h&lt;=t &amp;&amp; que[h]&lt;=i-(a-c-2)) ++h; while(h&lt;=t &amp;&amp; tmp[que[t]][j]&gt;tmp[i][j]) --t; que[++t] = i; if(i&gt;=a-1) res[i+1][j] = tmp[que[h]][j]; &#125; &#125; for (int i=a; i&lt;=n; ++i) &#123; for (int j=b; j&lt;=m; ++j) ans = max(ans, preg[i][j] - res[i][j]); &#125; printf("%d\n", ans); return 0;&#125; T4题意 生日礼物 有K种珠子共n个，分布在x轴上， 求包含k种珠子的最短线段长度。 1≤N≤1000000，1≤K≤60，0≤珠子位置&lt;2^31 思路 将珠子按x坐标排序后，随着x坐标的增大，种类只增不减，因此可以用单调队列维护种类大于等于k时的最短长度。 『 由于新加入的珠子除可能影响珠子种类数以外，不会对其他珠子产生影响，所以只需考虑队首元素出队的情况即可。 』 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;#define ri register intusing namespace std;const int maxn = 1e6+10;struct node &#123; int x, kind; inline bool operator&lt;(const node &amp;p) const &#123; return x&lt;p.x; &#125;&#125;ball[maxn];int n, K, pn;int que[maxn];int cnt[110], res, ans = INT_MAX;int main() &#123; ri h = 1, t = 0; scanf("%d%d", &amp;n, &amp;K); for (int x, k, i=1; i&lt;=K; ++i) &#123; scanf("%d", &amp;k); while(k--) &#123; scanf("%d", &amp;x); ball[++pn] = node&#123;x, i&#125;; &#125; &#125; sort(ball+1, ball+1+n); for (int i=1; i&lt;=n; ++i) &#123; que[++t] = i; if(!cnt[ball[que[t]].kind]) ++res; ++cnt[ball[que[t]].kind]; while(res==K) &#123; ans = min(ans, ball[que[t]].x - ball[que[h]].x); if(h&lt;=t) &#123; --cnt[ball[que[h]].kind]; if(!cnt[ball[que[h]].kind]) --res; ++h; &#125; &#125; &#125; printf("%d\n", ans); return 0;&#125; T5题意 股票交易 对于某只股票，已知它未来T天的走势，即 买入价ap, 卖出价bp， 买入数量上限as, 卖出数量上限bs。 限制条件： 手中最多p股，相邻的两次交易必须间隔w天。 假设手中有无穷多钱， 0股。 0≤W&lt;T≤2000,1≤MaxP≤2000，1≤bp≤ap≤1000,1≤as,bs≤Maxp 思路 对于第i天有四种情况： (1) 从0股开始买， f[i][j] = -ap[i]*j; (2) 啥也不干, f[i][j] = max(f[i][j], f[i-1][j]); (3) 买入：f[i][j] = max(f[i][j], f[i-w-1][k]-(j-k)*ap[i]); (4) 卖出：f[i][j] = max(f[i][j], f[i-w-1][k]+(k-j)*bp[i]); 对于(3),(4)暴力转移复杂度O(n^3), 仔细分析转移方程性质: max(f[i-w-1][k]+k*ap[i])-j*ap[i], 对于转移只需要知道最大的k即可，因此可用单调队列维护以下最大值即可。 考虑买入与卖出的关系，(3)需要正序,(4)需要倒序。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041 #include &lt;bits/stdc++.h&gt;#define ri register intusing namespace std;const int maxn = 1e6+10;struct node &#123; int x, kind; inline bool operator&lt;(const node &amp;p) const &#123; return x&lt;p.x; &#125;&#125;ball[maxn];int n, K, pn;int que[maxn];int cnt[110], res, ans = INT_MAX;int main() &#123; ri h = 1, t = 0; scanf("%d%d", &amp;n, &amp;K); for (int x, k, i=1; i&lt;=K; ++i) &#123; scanf("%d", &amp;k); while(k--) &#123; scanf("%d", &amp;x); ball[++pn] = node&#123;x, i&#125;; &#125; &#125; sort(ball+1, ball+1+n); for (int i=1; i&lt;=n; ++i) &#123; que[++t] = i; if(!cnt[ball[que[t]].kind]) ++res; ++cnt[ball[que[t]].kind]; while(res==K) &#123; ans = min(ans, ball[que[t]].x - ball[que[h]].x); if(h&lt;=t) &#123; --cnt[ball[que[h]].kind]; if(!cnt[ball[que[h]].kind]) --res; ++h; &#125; &#125; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>数据结构    -单调队列</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Erdös-Straus Conjecture（数学思维）]]></title>
    <url>%2F2019%2F04%2F17%2Fupc10282%2F</url>
    <content type="text"><![CDATA[题目描述The Brocard Erdös-Straus conjecture is that for any integer n &gt; 2, there are positive integers a ≤ b ≤ c, so that: (1) 4/n = 1/a + 1/b + 1/c There may be multiple solutions. For example: 4/18 = 1/9 + 1/10 + 1/90 = 1/5 + 1/90 + 1/90 = 1/5 + 1/46 + 1/2470 Since it is still a conjecture, there are obviously no counterexamples for n ≤ 50,000. For this problem, you will write a program which takes as input an integer n between 2 and 50000 inclusive and returns the smallest triple of integers a, b, c in lexicographic order which satisfies equation (1) above. That is, if a1, b1, c1 is any other solution to (1) for the given input, then either (a &lt; a1) or (a = a1 and b ≤ b1). 输入The first line of input contains a single decimal integer P, (1≤P≤1000), which is the number of data sets that follow. Each data set should be processed identically and independently. Each data set consists of a single line of input. It contains the data set number, K, followed by a single space, followed by the decimal integer n, (2≤n≤50000). 输出For each data set there is one line of output. The single output line consists of the data set number, K, followed by a single space followed by the decimal integer values a, b and c in that order, separated by single spaces. 样例输入 51 132 5293 498494 498505 18 样例输出 1 4 18 4682 133 23460 717641403 12463 207089366 116961831138966224 12463 310640276 964973807627159005 5 46 2070 题意给出 n（n&lt;=50000), 求满足 4/n = 1/a + 1/b + 1/c 的 a, b, c， 若存在多个， 则输出 abc 字典序最小的那组。 思路 4/n = 1/a + 1/b + 1/c=&gt; 4a = (1 + a/b + a/c) n=&gt; 4 a - n = (a/b + a/c) n=&gt; (4 a - n)/ (a n) = 1/b + 1/c=&gt; y/x = 1/b + 1/c=&gt; (y b - b)/(x b) = 1/c 通过公式推导可得： a &gt; n/4 b &gt; x/y 当 (y b - b)|(x b) 时， c = (x b)/(y b - b) 那么就可以通过枚举a， b 进行求解。 代码12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int _, k;int main() &#123; for (scanf("%d", &amp;_); _; _--) &#123; ll n; scanf("%lld", &amp;n); ll a, b, c; bool fg = false; for (a = n / 4 + 1; a &lt;= n / 2; ++a) &#123; ll x = a * n, y = 1ll * 4 * a - n; ll gcd = __gcd(x, y); y /= gcd, x /= gcd; for (b = x / y + 1; b &lt;= 2 * x / y; ++b) &#123; if ((x * n) % (y * b - x) == 0) &#123; c = (x * b) / (y * b - x); fg = 1; break; &#125; &#125; if (fg) break; &#125; printf("%d %lld %lld %lld\n", n, a, b, c); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Janken Master(概率dp/状压dp)]]></title>
    <url>%2F2019%2F04%2F17%2Fupc9726%2F</url>
    <content type="text"><![CDATA[题目描述You are supposed to play the rock-paper-scissors game. There are N players including you. This game consists of multiple rounds. While the rounds go, the number of remaining players decreases. In each round, each remaining player will select an arbitrary shape independently. People who show rocks win if all of the other people show scissors. In this same maNer, papers win rocks, scissors win papers. There is no draw situation due to the special rule of this game: if a round is tied based on the normal rock-paper-scissors game rule, the player who has the highest programming contest rating (this is nothing to do with the round!) will be the only wiNer of the round. Thus, some players win and the other players lose on each round. The losers drop out of the game and the wiNers proceed to a new round. They repeat it until only one player becomes the wiNer. Each player is numbered from 1 to N. Your number is 1. You know which shape the other N−1 players tend to show, that is to say, you know the probabilities each player shows rock, paper and scissors. The i-th player shows rock with ri% probability, paper with pi% probability, and scissors with si% probability. The rating of programming contest of the player numbered i is ai. There are no two players whose ratings are the same. Your task is to calculate your probability to win the game when you take an optimal strategy based on each player’s tendency and rating. 输入The input consists of a single test case formatted as follows. Na1a2 r2 p2 s2…aN rN pN sN The first line consists of a single integer N (2≤N≤14). The second line consists of a single integer ai (1≤ai≤N). The (i+1)-th line consists of four integers ai,ri,pi and si(1≤ai≤N,0≤ri,pi,si≤100, ri+pi+si=100) for i=2,…,N. It is guaranteed that a1,…,aN are pairwise distinct. 输出Print the probability to win the game in one line. Your answer will be accepted if its absolute or relative error does not exceed 10−6. 样例输入 221 40 40 20 样例输出 0.8 题意你要与 n-1 个人进行剪刀石头布的游戏。已知 n-1 个人的出剪刀石头布的概率，与rating (胜负规则同石头剪刀布游戏， 当达成平局时，rating高的人为唯一获胜者)对于每一轮游戏， 只有获胜的人能够晋级下一轮，当所有人都作出相同选择时，进入平局。 当场上只剩一个人时为获胜者，游戏结束。求自己的为获胜者的最大概率。 思路数据范围 n&lt;=14, 显然可以用状压dp。对于当前状态 mask， mask的二进制上为 1 时表示参与到游戏中的人。 对于每个mask， 可以通过枚举哪些人与自己出的一样， 哪些人与自己出的不一样， 同时维护一下平局时的获胜的概率。dp[mask] 则为自己出石头剪刀布三者获胜的最大概率。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt; using namespace std;const int maxn = 15;const int maxm = (1 &lt;&lt; 15);double dp[maxm];int n, f[maxn], x;double r[maxn], p[maxn], s[maxn]; int main() &#123; scanf("%d%d", &amp;n, &amp;x); --n; for (int i = 0; i &lt; n; ++i) &#123; int a, b, c, d; scanf("%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;d); f[i] = a / x; r[i] = b / 100.0; p[i] = c / 100.0; s[i] = d / 100.0; &#125; dp[0] = 1; for (int mask = 1; mask &lt; (1 &lt;&lt; n); ++mask) &#123; double rock = 0, paper = 0, scissor = 0; double rt = 1, pt = 1, st = 1; int k = 0; do &#123; if(k==mask) continue; double r1 = 1, p1 = 1, s1 = 1; double r2 = 1, p2 = 1, s2 = 1; for (int i = 0; i &lt; n; ++i) &#123; if (k &amp; (1 &lt;&lt; i)) &#123; r1 *= r[i]; p1 *= p[i]; s1 *= s[i]; &#125; else if (mask &amp; (1 &lt;&lt; i)) &#123; r2 *= r[i]; p2 *= p[i]; s2 *= s[i]; &#125; &#125; rock += r1 * s2 * dp[k]; rt -= r1 * (p2 + s2); paper += p1 * r2 * dp[k]; pt -= p1 * (r2 + s2); scissor += s1 * p2 * dp[k]; st -= s1 * (r2 + p2); &#125; while(k = (k-mask)&amp;mask); bool fg = false; for (int i = 0; i &lt; n; ++i) &#123; if ((mask &amp; (1 &lt;&lt; i)) &amp;&amp; f[i]) &#123; fg = 1; break; &#125; &#125; if (!fg) &#123; rock += rt, paper += pt, scissor += st; &#125; dp[mask] = max(rock, max(paper, scissor)); &#125; printf("%.6f\n", dp[(1 &lt;&lt; n) - 1]); return 0;&#125;]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>状压dp</tag>
        <tag>概率dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jurisdiction Disenchantment(二维尺取)]]></title>
    <url>%2F2019%2F04%2F15%2FJurisdiction-Disenchantment-%E4%BA%8C%E7%BB%B4%E5%B0%BA%E5%8F%96%2F</url>
    <content type="text"><![CDATA[题目描述The Super League of Paragons and Champions (SLPC) has been monitoring a plot by a corrupt politician to steal an election. In the past week, the politican has used a mind-control technique to enslave the n representatives responsible for choosing the election’s winner. Luckily, the SLPC has managed to recruit you and hence has access to your power to break mind-control. You are able to break mind-control in an axis-aligned rectangle. Unfortunately, your power comes at a steep cost; you get a headache the next day proportional to the size of the rectangle. You do not even want to risk or think about what would happen if you tried to use your power multiple times in one day.You have done your research and you know the position that each representative will be standing when the votes are about to be cast. You need to free enough representatives to prevent the politician from having a majority (strictly more than one-half) vote. What is the area of the smallest axis-aligned rectangle that you can affect to do this? 输入The first line of input contains a single integer T (1 ≤ T ≤ 10), the number of test cases. The first line of each test case contains a single integer n (1 ≤ n ≤ 299, n is odd), the number of representatives. Each of the next n lines of input contains two integers, denoting the x and y coordinates of a representative. It is guaranteed that all coordinates are between −10,000 and +10,000. 输出For each test case, output a single line containing the area of the smallest axis-aligned rectangle containing more than n/2 of the representatives. 样例输入 211 130 01 43 2 样例输出 04 提示In the first case, a rectangle containing a single point has an area of 0.In the second test case, the rectangle needs to include at least two points. There are two smallest possible rectangles; one includes (0, 0) and (1, 4) and the other includes (1, 4) and (3, 2). In either case, the area is 4. 题意有 n 个点，需要用一个矩形框 n/2+1 个点，求矩形最小面积。 思路二维尺取，把 n 个点按 x 降序排序， 枚举 x 的边界，维护在这个边界中 n/2+1 个点的最小矩形面积。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 300;const int inf = 0x7fffffff;int T, n;struct node &#123; int x, y; void read() &#123; scanf("%d%d", &amp;x, &amp;y); &#125; inline bool operator&lt;(const node &amp;p) &#123; return y &lt; p.y; &#125;&#125; a[maxn], b[maxn];bool cmp(node a, node b) &#123; return a.x &lt; b.x || a.x == b.x &amp;&amp; a.y &lt; b.y;&#125;int main() &#123; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; a[i].read(); b[i] = a[i]; &#125; sort(a + 1, a + 1 + n, cmp); int ans = INT_MAX, m = n / 2 + 1; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = i; j &lt;= n; ++j) &#123; int lx = a[i].x, rx = a[j].x; int cnt = 0; for (int k = 1; k &lt;= n; ++k) &#123; if (a[k].x &lt; lx || a[k].x &gt; rx) continue; b[++cnt] = a[k]; &#125; if (cnt &gt;= m) &#123; sort(b + 1, b + 1 + cnt); for (int k = 1; k &lt;= cnt - m + 1; ++k) &#123; int ly = b[k].y, ry = b[k + m - 1].y; ans = min(ans, (rx - lx) * (ry - ly)); &#125; &#125; &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>尺取</category>
      </categories>
      <tags>
        <tag>尺取</tag>
      </tags>
  </entry>
</search>
