<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[The Erdös-Straus Conjecture（数学思维）]]></title>
    <url>%2F2019%2F04%2F17%2Fupc10282%2F</url>
    <content type="text"><![CDATA[题目描述The Brocard Erdös-Straus conjecture is that for any integer n &gt; 2, there are positive integers a ≤ b ≤ c, so that: (1) 4/n = 1/a + 1/b + 1/cThere may be multiple solutions. For example:4/18 = 1/9 + 1/10 + 1/90 = 1/5 + 1/90 + 1/90 = 1/5 + 1/46 + 1/2470Since it is still a conjecture, there are obviously no counterexamples for n ≤ 50,000. For this problem, you will write a program which takes as input an integer n between 2 and 50000 inclusive and returns the smallest triple of integers a, b, c in lexicographic order which satisfies equation (1) above. That is, if a1, b1, c1 is any other solution to (1) for the given input, then either (a &lt; a1) or (a = a1 and b ≤ b1). 输入The first line of input contains a single decimal integer P, (1≤P≤1000), which is the number of data sets that follow. Each data set should be processed identically and independently. Each data set consists of a single line of input. It contains the data set number, K, followed by a single space, followed by the decimal integer n, (2≤n≤50000). 输出For each data set there is one line of output. The single output line consists of the data set number, K, followed by a single space followed by the decimal integer values a, b and c in that order, separated by single spaces. 样例输入 51 132 5293 498494 498505 18 样例输出 1 4 18 4682 133 23460 717641403 12463 207089366 116961831138966224 12463 310640276 964973807627159005 5 46 2070 题意给出 n（n&lt;=50000), 求满足 4/n = 1/a + 1/b + 1/c 的 a, b, c， 若存在多个， 则输出 abc 字典序最小的那组。 思路A(4/n = 1/a + 1/b + 1/c) –&gt; B(4a = (1 + a/b + a/c) n)B –&gt; C(4 a - n = (a/b + a/c) n)C –&gt; D((4 a - n)/ (a n) = 1/b + 1/c =&gt; y/x = 1/b + 1/c)D –&gt; E( (y b - b)/(x b) = 1/c) 通过公式推导可得： a &gt; n/4 b &gt; x/y 当 (y b - b)|(x b) 时， c = (x b)/(y b - b) 那么就可以通过枚举a， b 进行求解。 代码‵cpp #include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int _, k; int main() { for (scanf(“%d”, &amp;_); _; _–) { ll n; scanf(“%lld”, &amp;n); ll a, b, c; bool fg = false; for (a = n / 4 + 1; a &lt;= n / 2; ++a) { ll x = a n, y = 1ll 4 a - n; ll gcd = __gcd(x, y); y /= gcd, x /= gcd; for (b = x / y + 1; b &lt;= 2 x / y; ++b) { if ((x n) % (y b - x) == 0) { c = (x b) / (y b - x); fg = 1; break; } } if (fg) break; } printf(“%d %lld %lld %lld\n”, n, a, b, c); } return 0;}`]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Janken Master(概率dp/状压dp)]]></title>
    <url>%2F2019%2F04%2F16%2Fupc9726%2F</url>
    <content type="text"><![CDATA[题目描述You are supposed to play the rock-paper-scissors game. There are N players including you. This game consists of multiple rounds. While the rounds go, the number of remaining players decreases. In each round, each remaining player will select an arbitrary shape independently. People who show rocks win if all of the other people show scissors. In this same maNer, papers win rocks, scissors win papers. There is no draw situation due to the special rule of this game: if a round is tied based on the normal rock-paper-scissors game rule, the player who has the highest programming contest rating (this is nothing to do with the round!) will be the only wiNer of the round. Thus, some players win and the other players lose on each round. The losers drop out of the game and the wiNers proceed to a new round. They repeat it until only one player becomes the wiNer. Each player is numbered from 1 to N. Your number is 1. You know which shape the other N−1 players tend to show, that is to say, you know the probabilities each player shows rock, paper and scissors. The i-th player shows rock with ri% probability, paper with pi% probability, and scissors with si% probability. The rating of programming contest of the player numbered i is ai. There are no two players whose ratings are the same. Your task is to calculate your probability to win the game when you take an optimal strategy based on each player’s tendency and rating. 输入The input consists of a single test case formatted as follows. Na1a2 r2 p2 s2…aN rN pN sN The first line consists of a single integer N (2≤N≤14). The second line consists of a single integer ai (1≤ai≤N). The (i+1)-th line consists of four integers ai,ri,pi and si(1≤ai≤N,0≤ri,pi,si≤100, ri+pi+si=100) for i=2,…,N. It is guaranteed that a1,…,aN are pairwise distinct. 输出Print the probability to win the game in one line. Your answer will be accepted if its absolute or relative error does not exceed 10−6. 样例输入 221 40 40 20 样例输出 0.8 题意你要与 n-1 个人进行剪刀石头布的游戏。 已知 n-1 个人的出剪刀石头布的概率，与rating (胜负规则同石头剪刀布游戏， 当达成平局时，rating高的人为唯一获胜者) 对于每一轮游戏， 只有获胜的人能够晋级下一轮，当所有人都作出相同选择时，进入平局。 当场上只剩一个人时为获胜者，游戏结束。 求自己的为获胜者的最大概率。 思路数据范围 n&lt;=14, 显然可以用状压dp。 对于当前状态 mask， mask的二进制上为 1 时表示参与到游戏中的人。 对于每个mask， 可以通过枚举哪些人与自己出的一样， 哪些人与自己出的不一样， 同时维护一下平局时的获胜的概率。dp[mask] 则为自己出石头剪刀布三者获胜的最大概率。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt; using namespace std;const int maxn = 15;const int maxm = (1 &lt;&lt; 15);double dp[maxm];int n, f[maxn], x;double r[maxn], p[maxn], s[maxn]; int main() &#123; scanf("%d%d", &amp;n, &amp;x); --n; for (int i = 0; i &lt; n; ++i) &#123; int a, b, c, d; scanf("%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;d); f[i] = a / x; r[i] = b / 100.0; p[i] = c / 100.0; s[i] = d / 100.0; &#125; dp[0] = 1; for (int mask = 1; mask &lt; (1 &lt;&lt; n); ++mask) &#123; double rock = 0, paper = 0, scissor = 0; double rt = 1, pt = 1, st = 1; int k = 0; do &#123; if(k==mask) continue; double r1 = 1, p1 = 1, s1 = 1; double r2 = 1, p2 = 1, s2 = 1; for (int i = 0; i &lt; n; ++i) &#123; if (k &amp; (1 &lt;&lt; i)) &#123; r1 *= r[i]; p1 *= p[i]; s1 *= s[i]; &#125; else if (mask &amp; (1 &lt;&lt; i)) &#123; r2 *= r[i]; p2 *= p[i]; s2 *= s[i]; &#125; &#125; rock += r1 * s2 * dp[k]; rt -= r1 * (p2 + s2); paper += p1 * r2 * dp[k]; pt -= p1 * (r2 + s2); scissor += s1 * p2 * dp[k]; st -= s1 * (r2 + p2); &#125; while(k = (k-mask)&amp;mask); bool fg = false; for (int i = 0; i &lt; n; ++i) &#123; if ((mask &amp; (1 &lt;&lt; i)) &amp;&amp; f[i]) &#123; fg = 1; break; &#125; &#125; if (!fg) &#123; rock += rt, paper += pt, scissor += st; &#125; dp[mask] = max(rock, max(paper, scissor)); &#125; printf("%.6f\n", dp[(1 &lt;&lt; n) - 1]); return 0;&#125;]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>状压dp</tag>
        <tag>概率dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jurisdiction Disenchantment(二维尺取)]]></title>
    <url>%2F2019%2F04%2F15%2FJurisdiction-Disenchantment-%E4%BA%8C%E7%BB%B4%E5%B0%BA%E5%8F%96%2F</url>
    <content type="text"><![CDATA[题目描述The Super League of Paragons and Champions (SLPC) has been monitoring a plot by a corrupt politician to steal an election. In the past week, the politican has used a mind-control technique to enslave the n representatives responsible for choosing the election’s winner. Luckily, the SLPC has managed to recruit you and hence has access to your power to break mind-control. You are able to break mind-control in an axis-aligned rectangle. Unfortunately, your power comes at a steep cost; you get a headache the next day proportional to the size of the rectangle. You do not even want to risk or think about what would happen if you tried to use your power multiple times in one day.You have done your research and you know the position that each representative will be standing when the votes are about to be cast. You need to free enough representatives to prevent the politician from having a majority (strictly more than one-half) vote. What is the area of the smallest axis-aligned rectangle that you can affect to do this? 输入The first line of input contains a single integer T (1 ≤ T ≤ 10), the number of test cases. The first line of each test case contains a single integer n (1 ≤ n ≤ 299, n is odd), the number of representatives. Each of the next n lines of input contains two integers, denoting the x and y coordinates of a representative. It is guaranteed that all coordinates are between −10,000 and +10,000. 输出For each test case, output a single line containing the area of the smallest axis-aligned rectangle containing more than n/2 of the representatives. 样例输入 211 130 01 43 2 样例输出 04 提示In the first case, a rectangle containing a single point has an area of 0.In the second test case, the rectangle needs to include at least two points. There are two smallest possible rectangles; one includes (0, 0) and (1, 4) and the other includes (1, 4) and (3, 2). In either case, the area is 4. 题意有 n 个点，需要用一个矩形框 n/2+1 个点，求矩形最小面积。 思路二维尺取，把 n 个点按 x 降序排序， 枚举 x 的边界，维护在这个边界中 n/2+1 个点的最小矩形面积。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 300;const int inf = 0x7fffffff;int T, n;struct node &#123; int x, y; void read() &#123; scanf("%d%d", &amp;x, &amp;y); &#125; inline bool operator&lt;(const node &amp;p) &#123; return y &lt; p.y; &#125;&#125; a[maxn], b[maxn];bool cmp(node a, node b) &#123; return a.x &lt; b.x || a.x == b.x &amp;&amp; a.y &lt; b.y;&#125;int main() &#123; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; a[i].read(); b[i] = a[i]; &#125; sort(a + 1, a + 1 + n, cmp); int ans = INT_MAX, m = n / 2 + 1; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = i; j &lt;= n; ++j) &#123; int lx = a[i].x, rx = a[j].x; int cnt = 0; for (int k = 1; k &lt;= n; ++k) &#123; if (a[k].x &lt; lx || a[k].x &gt; rx) continue; b[++cnt] = a[k]; &#125; if (cnt &gt;= m) &#123; sort(b + 1, b + 1 + cnt); for (int k = 1; k &lt;= cnt - m + 1; ++k) &#123; int ly = b[k].y, ry = b[k + m - 1].y; ans = min(ans, (rx - lx) * (ry - ly)); &#125; &#125; &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>尺取</category>
      </categories>
      <tags>
        <tag>尺取</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
